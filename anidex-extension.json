{
    "id": "anidex-torrent-provider",
    "name": "AniDex Torrent Provider",
    "description": "Anime torrent provider for AniDex",
    "manifestURI": "https://raw.githubusercontent.com/MidnightKittenCat/testextension/main/anidex-extension.json",
    "version": "1.0.2",
    "author": "Your Name",
    "type": "anime-torrent-provider",
    "language": "typescript",
    "lang": "multi",
    "payload": "/// <reference path=\"./anime-torrent-provider.d.ts\" />\n\nclass Provider {\n    private baseUrl = \"https://anidex.info/\";\n    private userAgent = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\";\n\n    getSettings(): AnimeProviderSettings {\n        return {\n            canSmartSearch: false,\n            smartSearchFilters: [],\n            supportsAdult: true,\n            type: \"main\",\n        };\n    }\n\n    async search(opts: AnimeSearchOptions): Promise<AnimeTorrent[]> {\n        const url = this.buildSearchUrl(opts.query);\n        const html = await this.fetchHtmlWithRetry(url);\n        return this.parseTorrents(html);\n    }\n\n    async smartSearch(opts: AnimeSmartSearchOptions): Promise<AnimeTorrent[]> {\n        const query = opts.title + (opts.episodeNumber ? ` ${opts.episodeNumber}` : \"\");\n        return this.search({ query });\n    }\n\n    async getTorrentInfoHash(torrent: AnimeTorrent): Promise<string> {\n        return torrent.infoHash || \"\";\n    }\n\n    async getTorrentMagnetLink(torrent: AnimeTorrent): Promise<string> {\n        if (torrent.magnetLink) return torrent.magnetLink;\n\n        const torrentPage = await this.fetchHtmlWithRetry(torrent.link);\n        const $ = LoadDoc(torrentPage);\n        const magnetLink = $('a[href^=\"magnet:?xt=urn:btih:\"]').attr(\"href\");\n        return magnetLink || \"\";\n    }\n\n    async getLatest(): Promise<AnimeTorrent[]> {\n        const html = await this.fetchHtmlWithRetry(this.baseUrl);\n        return this.parseTorrents(html);\n    }\n\n    private buildSearchUrl(query: string): string {\n        return `${this.baseUrl}?q=${encodeURIComponent(query)}&s=seeders&o=desc`;\n    }\n\n    private async fetchHtmlWithRetry(url: string, retries = 3): Promise<string> {\n        for (let i = 0; i < retries; i++) {\n            try {\n                await this.delay(1000 * (i + 1)); // Increasing delay for each retry\n                const response = await fetch(url, {\n                    headers: {\n                        'User-Agent': this.userAgent,\n                        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n                        'Accept-Language': 'en-US,en;q=0.5',\n                        'Referer': this.baseUrl,\n                    }\n                });\n                if (!response.ok) {\n                    throw new Error(`HTTP error! status: ${response.status}`);\n                }\n                return await response.text();\n            } catch (error) {\n                console.error(`Attempt ${i + 1} failed to fetch ${url}: ${error}`);\n                if (i === retries - 1) throw error;\n            }\n        }\n        throw new Error(`Failed to fetch ${url} after ${retries} attempts`);\n    }\n\n    private async delay(ms: number): Promise<void> {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    private parseTorrents(html: string): AnimeTorrent[] {\n        const $ = LoadDoc(html);\n        const torrents: AnimeTorrent[] = [];\n\n        $(\"tbody tr\").each((_, row) => {\n            const $row = $(row);\n            const name = $row.find(\"td:nth-child(3) a\").text().trim();\n            const link = this.resolveUrl($row.find(\"td:nth-child(3) a\").attr(\"href\") || \"\");\n            const size = $row.find(\"td:nth-child(7)\").text().trim();\n            const seeders = parseInt($row.find(\"td:nth-child(9)\").text().trim(), 10) || 0;\n            const leechers = parseInt($row.find(\"td:nth-child(10)\").text().trim(), 10) || 0;\n            const date = $row.find(\"td:nth-child(8)\").text().trim();\n\n            torrents.push({\n                name,\n                link,\n                size: this.parseSize(size),\n                formattedSize: size,\n                seeders,\n                leechers,\n                downloadCount: 0,\n                date: this.parseDate(date),\n                downloadUrl: \"\",\n                magnetLink: \"\",\n                infoHash: \"\",\n                resolution: this.parseResolution(name),\n                isBatch: name.toLowerCase().includes(\"batch\"),\n                isBestRelease: false,\n                confirmed: true,\n            });\n        });\n\n        return torrents;\n    }\n\n    private parseSize(size: string): number {\n        const units = { B: 1, KB: 1024, MB: 1024 * 1024, GB: 1024 * 1024 * 1024 };\n        const [value, unit] = size.split(\" \");\n        return parseFloat(value) * (units[unit as keyof typeof units] || 1);\n    }\n\n    private parseDate(date: string): string {\n        try {\n            return new Date(date).toISOString();\n        } catch (error) {\n            console.error(`Failed to parse date: ${date}`);\n            return new Date().toISOString(); // Return current date as fallback\n        }\n    }\n\n    private parseResolution(name: string): string {\n        const resolutions = [\"4K\", \"2160p\", \"1080p\", \"720p\", \"480p\"];\n        for (const res of resolutions) {\n            if (name.includes(res)) return res;\n        }\n        return \"\";\n    }\n\n    private resolveUrl(path: string): string {\n        if (path.startsWith('http://') || path.startsWith('https://')) {\n            return path;\n        }\n        return new URL(path, this.baseUrl).toString();\n    }\n}"
}
