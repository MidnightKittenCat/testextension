{
    "id": "anidex-torrent-provider",
    "name": "AniDex Torrent Provider",
    "description": "An extension to search and fetch anime torrents from AniDex",
    "manifestURI": "",
    "version": "1.0.0",
    "author": "Your Name",
    "type": "anime-torrent-provider",
    "language": "typescript",
    "lang": "en",
    "payload": "/// <reference path=\"./anime-torrent-provider.d.ts\" />\n\nclass Provider {\n    private api = \"https://anidex.info\";\n\n    async getSettings(): Promise<AnimeProviderSettings> {\n        return {\n            canSmartSearch: true,\n            smartSearchFilters: [\"batch\", \"episodeNumber\", \"resolution\", \"query\"],\n            supportsAdult: true,\n            type: \"main\",\n        };\n    }\n\n    async search(opts: AnimeSearchOptions): Promise<AnimeTorrent[]> {\n        const url = `${this.api}/?q=${encodeURIComponent(opts.query)}`;\n        return this.fetchTorrents(url);\n    }\n\n    async smartSearch(opts: AnimeSmartSearchOptions): Promise<AnimeTorrent[]> {\n        let query = opts.query || opts.media.romajiTitle || opts.media.englishTitle;\n        if (opts.batch) query += \" batch\";\n        if (opts.episodeNumber > 0) query += ` episode ${opts.episodeNumber}`;\n        if (opts.resolution) query += ` ${opts.resolution}`;\n\n        const url = `${this.api}/?q=${encodeURIComponent(query)}`;\n        return this.fetchTorrents(url);\n    }\n\n    async getTorrentInfoHash(torrent: AnimeTorrent): Promise<string> {\n        if (torrent.infoHash) return torrent.infoHash;\n        return this.scrapeTorrentPage(torrent.link, 'infoHash');\n    }\n\n    async getTorrentMagnetLink(torrent: AnimeTorrent): Promise<string> {\n        if (torrent.magnetLink) return torrent.magnetLink;\n        return this.scrapeTorrentPage(torrent.link, 'magnetLink');\n    }\n\n    async getLatest(): Promise<AnimeTorrent[]> {\n        const url = `${this.api}/?s=id&o=desc`;\n        return this.fetchTorrents(url);\n    }\n\n    private async fetchTorrents(url: string): Promise<AnimeTorrent[]> {\n        try {\n            const response = await fetch(url);\n            const html = await response.text();\n            return this.parseTorrents(html);\n        } catch (error) {\n            console.error(\"Error fetching torrents:\", error);\n            return [];\n        }\n    }\n\n    private parseTorrents(html: string): AnimeTorrent[] {\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(html, 'text/html');\n        const rows = doc.querySelectorAll('table.table-hover > tbody > tr');\n        \n        return Array.from(rows).map(row => {\n            const nameElement = row.querySelector('td:nth-child(3) a');\n            const name = nameElement?.textContent?.trim() || '';\n            const link = nameElement?.getAttribute('href') || '';\n            const size = row.querySelector('td:nth-child(7)')?.textContent?.trim() || '';\n            const seeders = parseInt(row.querySelector('td:nth-child(9)')?.textContent?.trim() || '0', 10);\n            const leechers = parseInt(row.querySelector('td:nth-child(10)')?.textContent?.trim() || '0', 10);\n            const downloadCount = parseInt(row.querySelector('td:nth-child(8)')?.textContent?.trim() || '0', 10);\n            const dateElement = row.querySelector('td:nth-child(5)');\n            const date = dateElement ? new Date(dateElement.getAttribute('title') || '').toISOString() : new Date().toISOString();\n\n            return {\n                name,\n                date,\n                size: this.parseSize(size),\n                formattedSize: size,\n                seeders,\n                leechers,\n                downloadCount,\n                link: `${this.api}${link}`,\n                downloadUrl: '',\n                magnetLink: null,\n                infoHash: null,\n                resolution: this.parseResolution(name),\n                isBatch: name.toLowerCase().includes('batch'),\n                episodeNumber: this.parseEpisodeNumber(name),\n                releaseGroup: this.parseReleaseGroup(name),\n                isBestRelease: false,\n                confirmed: false,\n            };\n        });\n    }\n\n    private parseSize(size: string): number {\n        const match = size.match(/^([\\d.]+)\\s*([KMGT]?B)$/i);\n        if (!match) return 0;\n        const [, value, unit] = match;\n        const multipliers: { [key: string]: number } = { B: 1, KB: 1024, MB: 1024 ** 2, GB: 1024 ** 3, TB: 1024 ** 4 };\n        return parseFloat(value) * multipliers[unit.toUpperCase()];\n    }\n\n    private parseResolution(name: string): string {\n        const resolutions = ['4K', '1080p', '720p', '480p'];\n        for (const res of resolutions) {\n            if (name.includes(res)) return res;\n        }\n        return '';\n    }\n\n    private parseEpisodeNumber(name: string): number {\n        const match = name.match(/\\b(?:E|EP|Episode)\\s*(\\d+)\\b/i);\n        return match ? parseInt(match[1], 10) : -1;\n    }\n\n    private parseReleaseGroup(name: string): string {\n        const match = name.match(/\\[([^\\]]+)\\]/);\n        return match ? match[1] : '';\n    }\n\n    private async scrapeTorrentPage(url: string, type: 'infoHash' | 'magnetLink'): Promise<string> {\n        try {\n            const response = await fetch(url);\n            const html = await response.text();\n            const parser = new DOMParser();\n            const doc = parser.parseFromString(html, 'text/html');\n\n            if (type === 'infoHash') {\n                const infoHashElement = doc.querySelector('.info-hash');\n                return infoHashElement?.textContent?.trim() || '';\n            } else {\n                const magnetLink = doc.querySelector('a[href^=\"magnet:\"]')?.getAttribute('href') || '';\n                return magnetLink;\n            }\n        } catch (error) {\n            console.error(`Error scraping ${type}:`, error);\n            return '';\n        }\n    }\n}"
}
