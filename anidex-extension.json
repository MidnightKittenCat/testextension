{
    "id": "anidex-torrent-provider",
    "name": "AniDex Torrent Provider",
    "description": "Anime torrent provider for AniDex",
    "manifestURI": "",
    "version": "1.0.0",
    "author": "Your Name",
    "type": "anime-torrent-provider",
    "language": "typescript",
    "lang": "multi",
    "payload": "/// <reference path=\"./anime-torrent-provider.d.ts\" />\n\nclass Provider {\n    private baseUrl = \"https://anidex.info/\";\n\n    getSettings(): AnimeProviderSettings {\n        return {\n            canSmartSearch: false,\n            smartSearchFilters: [],\n            supportsAdult: true,\n            type: \"main\",\n        };\n    }\n\n    async search(opts: AnimeSearchOptions): Promise<AnimeTorrent[]> {\n        const url = this.buildSearchUrl(opts.query);\n        const html = await this.fetchHtml(url);\n        return this.parseTorrents(html);\n    }\n\n    async smartSearch(opts: AnimeSmartSearchOptions): Promise<AnimeTorrent[]> {\n        // AniDex doesn't support smart search, so we'll use regular search\n        const query = opts.title + (opts.episodeNumber ? ` ${opts.episodeNumber}` : \"\");\n        return this.search({ query });\n    }\n\n    async getTorrentInfoHash(torrent: AnimeTorrent): Promise<string> {\n        return torrent.infoHash || \"\";\n    }\n\n    async getTorrentMagnetLink(torrent: AnimeTorrent): Promise<string> {\n        if (torrent.magnetLink) return torrent.magnetLink;\n\n        const torrentPage = await this.fetchHtml(torrent.link);\n        const $ = LoadDoc(torrentPage);\n        const magnetLink = $('a[href^=\"magnet:?xt=urn:btih:\"]').attr(\"href\");\n        return magnetLink || \"\";\n    }\n\n    async getLatest(): Promise<AnimeTorrent[]> {\n        const url = this.baseUrl;\n        const html = await this.fetchHtml(url);\n        return this.parseTorrents(html);\n    }\n\n    private buildSearchUrl(query: string): string {\n        return `${this.baseUrl}?q=${encodeURIComponent(query)}&s=seeders&o=desc`;\n    }\n\n    private async fetchHtml(url: string): Promise<string> {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`Failed to fetch ${url}: ${response.statusText}`);\n        }\n        return response.text();\n    }\n\n    private parseTorrents(html: string): AnimeTorrent[] {\n        const $ = LoadDoc(html);\n        const torrents: AnimeTorrent[] = [];\n\n        $(\"tbody tr\").each((_, row) => {\n            const $row = $(row);\n            const name = $row.find(\"td:nth-child(3) a\").text().trim();\n            const link = this.baseUrl + $row.find(\"td:nth-child(3) a\").attr(\"href\");\n            const size = $row.find(\"td:nth-child(7)\").text().trim();\n            const seeders = parseInt($row.find(\"td:nth-child(9)\").text().trim(), 10);\n            const leechers = parseInt($row.find(\"td:nth-child(10)\").text().trim(), 10);\n            const date = $row.find(\"td:nth-child(8)\").text().trim();\n\n            torrents.push({\n                name,\n                link,\n                size: this.parseSize(size),\n                formattedSize: size,\n                seeders,\n                leechers,\n                downloadCount: 0,\n                date: this.parseDate(date),\n                downloadUrl: \"\",\n                magnetLink: \"\",\n                infoHash: \"\",\n                resolution: this.parseResolution(name),\n                isBatch: name.toLowerCase().includes(\"batch\"),\n                isBestRelease: false,\n                confirmed: true,\n            });\n        });\n\n        return torrents;\n    }\n\n    private parseSize(size: string): number {\n        const units = { B: 1, KB: 1024, MB: 1024 * 1024, GB: 1024 * 1024 * 1024 };\n        const [value, unit] = size.split(\" \");\n        return parseFloat(value) * units[unit as keyof typeof units];\n    }\n\n    private parseDate(date: string): string {\n        // Assuming date format is like \"2023-09-15 15:30\"\n        return new Date(date).toISOString();\n    }\n\n    private parseResolution(name: string): string {\n        const resolutions = [\"4K\", \"2160p\", \"1080p\", \"720p\", \"480p\"];\n        for (const res of resolutions) {\n            if (name.includes(res)) return res;\n        }\n        return \"\";\n    }\n}"
}
